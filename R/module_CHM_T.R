#' Prepare data for module: CHM_T (Transcript)
#'
#' The workflow of vigilante is highly module-based. To ensure a successful and smooth run, vigilante needs to prepare input data before continuing.
#'
#' @param doTE logic, whether to prepare Transcript Expression (TE) data, if FALSE, no TE data will be available for downstream v_chmTranscript function; if TRUE, please make sure TE data files are properly named, see Details for more information about file naming.
#' @param customFileName_selection string, relative or absolute path to the custom transcript selection data file, can be set to "example" and use vigilante-embedded example transcript selection data, see Details for more information.
#' @param selectBy character, choose one from c("ENST", "ENSG", "Gene"), use which ID/name to select target transcripts; "ENST" for ENSEMBL transcript ID, "ENSG" for ENSEMBL gene ID, "Gene" for gene name.
#' @param customFileName_commonName (optional) string, relative or absolute path to the custom transcript common name data file, can be set to "example" and use vigilante-embedded example transcript common name data, see Details for more information.
#' @param addCommonName logic, whether to add common name for corresponding transcript in downstream analysis; will be overriden and reset to FALSE if customFileName_commonName is not properly provided.
#'
#' @details
#' Oftentimes input data files generated by upstream tools came with diverse naming conventions. It might be easy for the user to recognize those files, but not for vigilante if there is no recognizable patterns.
#'
#' To make input data files clear to vigilante, it would be nice to have them named something like "studyID_sampleID_(other descriptions).file extension". Here "studyID" is the name of the study or project, and it will be used in multiple naming situations (such as on the plot, or in the output file names), so it is recommended to be concise and meaningful.
#'
#' For module CHM_T, currently supported input data files are listed below, please contact the author if you want to add more files to the supported list:
#' Transcript Expression (GE): *cufflinks.isoforms* for Cufflinks
#'
#' Here is more information about 'customFileName_selection'. To begin with, user can provide a csv file through 'customFileName_selection' containing a panel of transcripts/genes in dataframe format (check vigilante.knights.sword::transcript_selection for example) if user already has some transcripts/genes of interest in mind and wants to check how those transcripts (or transcripts of the selected genes) perform. Note there are 3 columns in the example, but in practice user only needs to provide 1 column and set 'selectBy' to match the provided data: "ENST" for ENSEMBL transcript ID, "ENSG" for ENSEMBL gene ID, "Gene" for gene name.
#'
#' Here is more information about 'customFileName_commonName'. Similar to 'customFileName_selection', but it is optional, user can provide a csv file through 'customFileName_commonName' containing a panel of transcripts in dataframe format (check vigilante.knights.sword::transcript_commonName for example) if user already has some (transcript ID-common name) pair and wants to use them in downstream analysis.
#'
#' For both 'customFileName_selection' and 'customFileName_commonName', there is an alternative option by setting the value to "example"; in this way, user can try the embedded example data (derived from external public available data) and get an idea of how this function works.
#'
#' @return list, because R CMD check discourages assignments to the global environment within functions, user needs to run the function with explicitly assigning the return value to a global variable named "prepareVdata_CHM_T_returnList", which will be a list containing the required variables for downstream analyses.
#'
#' @export
#'
# v_prepareVdata_CHM_T function
v_prepareVdata_CHM_T = function(doTE = FALSE, customFileName_selection = NULL, selectBy = "ENST", customFileName_commonName = NULL, addCommonName = FALSE) {

  # ask user to make sure v_prepareVdata_CHM_T function return value is assigned to the global variable named "prepareVdata_CHM_T_returnList"
  status_returnValue = menu(choices = c("Yes", "No"), title = "\nIs v_prepareVdata_CHM_T function return value assigned to the global variable named 'prepareVdata_CHM_T_returnList'?")
  if (status_returnValue == 1) {
    print("Function return value is properly assigned, now continue to the next step")
  } else if (status_returnValue == 2) {
    print("Please follow the instruction to assign the function return value before continue to the next step")
    stop()
  } else {
    print("Please choose a valid answer")
    stop()
  }
  rm(status_returnValue)

  # check if globalSettings_returnList exists
  if (!exists("globalSettings_returnList")) {
    print("globalSettings_returnList not detected, please follow the instruction and run v_globalSettings function before continue")
    stop()
  } else {
    print("globalSettings_returnList detected, start extracting global settings")
  }

  # extract global settings from return list
  for (i in 1:length(globalSettings_returnList)) {
    assign(x = names(globalSettings_returnList)[i], value = globalSettings_returnList[[i]])
  }
  rm(i)

  # preset variables for temp_prepareVdata_CHM_T_returnList
  te_loader_par = NULL
  te.list.c = NULL
  assayID_rna = NULL
  plot_name_rna = NULL

  # if condition for whether to reform TE data
  if (doTE == TRUE) {

    # check and load transcript_selection
    if (is.null(customFileName_selection)) {
      print("Transcript selection data not detected, please double check if 'customFileName_selection' is properly provided; set it to 'example' to try the embedded example transcript selection data, or set doTE = FALSE to skip TE data processing")
      stop()
    } else if (customFileName_selection == "example") {
      print("Start loading example transcript selection data")
      te_loader_par = list()
      te_loader_par[["transcript_selection"]] = vigilante.knights.sword::transcript_selection
    } else {
      print("Transcript selection data detected, start loading")
      te_loader_par = list()
      te_loader_par[["transcript_selection"]] = read.csv(customFileName_selection, stringsAsFactors = FALSE)
      colnames(te_loader_par$transcript_selection) = selectBy
    }

    # set selectBy
    te_loader_par[["selectBy"]] = selectBy

    # check and load transcript_commonName
    if (is.null(customFileName_commonName)) {
      print("Transcript common name data not detected, overriding and resetting addCommonName = FALSE, will skip adding common name for corresponding transcript in downstream analysis; or set it to 'example' to try the embedded example transcript common name data")
      te_loader_par[["transcript_commonName"]] = NA
      addCommonName = FALSE
    } else if (customFileName_commonName == "example") {
      print("Start loading example transcript common name data")
      te_loader_par[["transcript_commonName"]] = vigilante.knights.sword::transcript_commonName
    } else {
      print("Transcript comman name data detected, start loading")
      te_loader_par[["transcript_commonName"]] = read.csv(customFileName_commonName, stringsAsFactors = FALSE)
      colnames(te_loader_par$transcript_commonName) = c("Transcript", "Common_Name")
    }
    if (!is.na(te_loader_par["transcript_commonName"])) {
      te_loader_par[["transcript_commonName"]]["Combined_Name"] = paste0(te_loader_par[["transcript_commonName"]][, "Transcript"], "/", te_loader_par[["transcript_commonName"]][, "Common_Name"])
    }

    # set addCommonName
    te_loader_par[["addCommonName"]] = addCommonName

    # remove ENST/ENSG version suffix in te_loader_par
    if (selectBy == "ENST") {
      te_loader_par[["transcript_selection"]]$ENST = gsub("\\.[[:digit:]]+$", "", te_loader_par[["transcript_selection"]]$ENST)
    } else if (selectBy == "ENSG") {
      te_loader_par[["transcript_selection"]]$ENSG = gsub("\\.[[:digit:]]+$", "", te_loader_par[["transcript_selection"]]$ENSG)
    }

    # check if TE data exist
    te_file_name = dir(path = folder_name, pattern = glob2rx("*cufflinks.isoforms*"))
    if (length(te_file_name) == 0) {
      print("TE data not detected, please double check if TE data files are properly named, or set doTE = FALSE to skip TE data processing")
      stop()
    } else {
      print("Start processing TE data")
    }

    # load and extract trascript expression data
    te_path = paste0("./", folder_name, "/", te_file_name)
    te.list = lapply(te_path, read.table, header = TRUE, stringsAsFactors = FALSE)
    te.list = lapply(te.list, function(x) x[(names(x) %in% c("tracking_id", "gene_id", "gene_short_name", "FPKM", "FPKM_status"))])
    te_header = c("ENST", "ENSG", "Gene", "FPKM", "FPKM_status")
    te.list = lapply(te.list, setNames, te_header)
    names(te.list) = assayID

    # filter out sample with empty te data, using backwards for loop
    plot_name_rna = plot_name
    assayID_rna = assayID
    for (i in length(te.list):1) {
      if (nrow(te.list[[i]]) == 0) {
        te.list[[i]] = NULL
        plot_name_rna = plot_name_rna[-i]
        assayID_rna = assayID_rna[-i]
      }
    }
    rm(i)

    # select samples in groupInfo
    te.list = te.list[names(te.list) %in% groupInfo$assayID]

    # remove ENST/ENSG version suffix in te.list
    te.list = lapply(te.list, function(x) {
      x$ENST = gsub("\\.[[:digit:]]+$", "", x$ENST)
      x$ENSG = gsub("\\.[[:digit:]]+$", "", x$ENSG)
      return(x)
    })

    # pick up transcripts associated with target gene
    te.list.full = te.list
    if (te_loader_par[["selectBy"]] == "ENST") {
      te.list = lapply(te.list, function(x) {
        x = subset(x, subset = ENST %in% te_loader_par[["transcript_selection"]]$ENST)
        return(x)
      })
    } else if (te_loader_par[["selectBy"]] == "ENSG") {
      te.list = lapply(te.list, function(x) {
        x = subset(x, subset = ENSG %in% te_loader_par[["transcript_selection"]]$ENSG)
        return(x)
      })
    } else if (te_loader_par[["selectBy"]] == "Gene") {
      te.list = lapply(te.list, function(x) {
        x = subset(x, subset = Gene %in% te_loader_par[["transcript_selection"]]$Gene)
        return(x)
      })
    }

    # normalize possible computational artifact and convert FPKM to TPM
    te.list.full = lapply(te.list.full, function(x) {
      x = x[, c("ENST", "FPKM")]
      x[x[, "FPKM"] < 0.001, "FPKM"] = 0 # normalize possible computational artifact with 0
      return(x)
    })
    te.list = lapply(te.list, function(x) {
      x[x[, "FPKM"] < 0.001, "FPKM"] = 0 # normalize possible computational artifact with 0
      return(x)
    })
    te.list = mapply(x = te.list, y = te.list.full, SIMPLIFY = FALSE, function(x, y) {
      sumFPKM = sum(y["FPKM"])
      x["TPM"] = x["FPKM"] / sumFPKM * (10 ^ 6)
      x["FPKM"] = NULL
      return(x)
    })
    rm(te.list.full)

    # map trascript expression data to GRCh38T/GRCm38T
    if (speciesID == "hg38") {
      te.list = lapply(te.list, merge, x = GRCh38T, by = c("ENST", "Gene"))
    } else if (speciesID == "hg19") {
      te.list = lapply(te.list, merge, x = GRCh37T, by = c("ENST", "Gene"))
    } else {
      te.list = lapply(te.list, merge, x = GRCm38T, by = c("ENST", "Gene"))
    }

    # extract "FPKM_status == OK" variants for downstream analysis
    te.list = lapply(te.list, function(x) {
      x = subset(x, subset = FPKM_status == "OK")
      return(x)
    })
    te.list = lapply(te.list, function(x) x[, c("Transcript", "Gene", "TPM")])

    # add "Gene: " prefix to Gene column for heatmap mainbody plotting
    te.list = lapply(te.list, function(x) {
      x[, "Gene"] = paste0("Gene: ", x[, "Gene"])
      return(x)
    })

    # extract all unique genes for downstream loop and rowSliceOrder
    te_rowSlice = lapply(te.list, function(x) x = unlist(unique(x$Gene)))
    te_rowSlice = as.character(unlist(te_rowSlice))
    te_rowSlice = sort(unique(te_rowSlice))
    te_loader_par[["te_rowSlice"]] = te_rowSlice

    # add common names for transcripts
    if (te_loader_par[["addCommonName"]] == TRUE) {
      te.list = lapply(te.list, function(x) {
        x[, "Transcript"] = plyr::mapvalues(x[, "Transcript"], from = te_loader_par[["transcript_commonName"]][, "Transcript"], to = te_loader_par[["transcript_commonName"]][, "Combined_Name"], warn_missing = FALSE)
        return(x)
      })
    }

    # set t2gMapping for downstream grouping and sorting
    t2gMapping = lapply(te.list, function(x) x = x[, -3])
    t2gMapping = dplyr::bind_rows(t2gMapping)
    t2gMapping = unique(t2gMapping)
    te_loader_par[["t2gMapping"]] = t2gMapping

    # set te.list.c and separate te.list based on genes
    te.list_combined = te.list
    te.list_separated = list()
    for (i in 1:length(te_loader_par[["te_rowSlice"]])) {
      te.list_separated[[i]] = lapply(te.list, function(x) x = subset(x, subset = x$Gene == te_loader_par[["te_rowSlice"]][i]))
    }
    rm(i)
    names(te.list_separated) = te_loader_par[["te_rowSlice"]]
    te.list.c = te.list_separated
    te.list.c[["combined"]] = te.list_combined

    # remove temp te data
    rm(te_file_name, te_path, te_header, te_rowSlice, t2gMapping, te.list, te.list_combined, te.list_separated)
  }

  # add variables to temp_prepareVdata_CHM_T_returnList
  temp_prepareVdata_CHM_T_returnList = list(
    "te_loader_par" = te_loader_par,
    "te.list.c" = te.list.c,
    "assayID_rna" = assayID_rna,
    "plot_name_rna" = plot_name_rna
  )

  # remove variables already added to temp_prepareVdata_CHM_T_returnList
  rm(list = names(temp_prepareVdata_CHM_T_returnList))

  # filter out empty variables, using backwards for loop
  for (i in length(temp_prepareVdata_CHM_T_returnList):1) {
    if (is.null(temp_prepareVdata_CHM_T_returnList[[i]])) {
      temp_prepareVdata_CHM_T_returnList[[i]] = NULL
    }
  }
  rm(i)

  # remove extracted global settings
  rm(list = names(globalSettings_returnList))

  # end of v_prepareVdata_CHM_T function
  print("v_prepareVdata_CHM_T run completed, return value saved to the global environment in **prepareVdata_CHM_T_returnList**")
  return(temp_prepareVdata_CHM_T_returnList)
}

# preset globalVariables for R CMD check
utils::globalVariables(c("ENST", "FPKM_status", "GRCh37T", "GRCh38T", "GRCm38T"))
