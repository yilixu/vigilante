#' Prepare data for module: xCell
#'
#' The workflow of vigilante is highly module-based. To ensure a successful and smooth run, vigilante needs to prepare input data before continuing.
#'
#' @param doGE logic, whether to prepare Gene Expression (GE) data, if FALSE, no GE data will be available for downstream v_chmXcell function; if TRUE, please make sure GE data files are properly named, see Details for more information about file naming.
#' @param doLocalAnalysis logic, whether to perform local Cell Type Enrichment Analysis (based on xCell), if FALSE, no local analysis results will be available for downstream v_chmXcell function.
#' @param colSliceOrder character vector, the order (from left to right) of groups to be shown on the output plots and files, should be set to the same value when called from different functions within the same module (e.g., v_prepareVdata_xCell and v_chmXcell). By default will use the internal character vector "grpName" and can be left unchanged. Groups not included in the "colSliceOrder" will also be excluded from the output plots and files (in most cases), and from certain analysis process (depending on the situation).
#'
#' @details
#' Oftentimes input data files generated by upstream tools came with diverse naming conventions. It might be easy for the user to recognize those files, but not for vigilante if there is no recognizable patterns.
#'
#' To make input data files clear to vigilante, it would be nice to have them named something like "studyID_sampleID_(other descriptions).file extension". Here "studyID" is the name of the study or project, and it will be used in multiple naming situations (such as on the plot, or in the output file names), so it is recommended to be concise and meaningful.
#'
#' For module xCell, currently supported input data files are listed below, please contact the author if you want to add more files to the supported list:
#' Gene Expression (GE): *cDNA_genes.sf for Salmon
#'
#' @return list, because R CMD check discourages assignments to the global environment within functions, user needs to run the function with explicitly assigning the return value to a global variable named "prepareVdata_xCell_returnList", which will be a list containing the required variables for downstream analyses.
#'
#' @export
#'
# v_prepareVdata_xCell function
v_prepareVdata_xCell = function(doGE = FALSE, doLocalAnalysis = FALSE, colSliceOrder = grpName) {

  # ask user to make sure v_prepareVdata_xCell function return value is assigned to the global variable named "prepareVdata_xCell_returnList"
  status_returnValue = menu(choices = c("Yes", "No"), title = "\nIs v_prepareVdata_xCell function return value assigned to the global variable named 'prepareVdata_xCell_returnList'?")
  if (status_returnValue == 1) {
    print("Function return value is properly assigned, now continue to the next step")
  } else if (status_returnValue == 2) {
    print("Please follow the instruction to assign the function return value before continue to the next step")
    stop()
  } else {
    print("Please choose a valid answer")
    stop()
  }
  rm(status_returnValue)

  # check if globalSettings_returnList exists
  if (!exists("globalSettings_returnList")) {
    print("globalSettings_returnList not detected, please follow the instruction and run v_globalSettings function before continue")
    stop()
  } else {
    print("globalSettings_returnList detected, start extracting global settings")
  }

  # extract global settings from return list
  for (i in 1:length(globalSettings_returnList)) {
    assign(x = names(globalSettings_returnList)[i], value = globalSettings_returnList[[i]])
  }
  rm(i)

  # preset variables for temp_prepareVdata_xCell_returnList
  ge.list.c = NULL
  ge.xcell = NULL
  ge.xcell.result = NULL
  assayID_rna = NULL
  plot_name_rna = NULL

  # if condition for whether to reform GE data
  if (doGE == TRUE) {

    # check if GE data exist
    ge_file_name = dir(path = folder_name, pattern = glob2rx("*cDNA_genes.sf"))
    if (length(ge_file_name) == 0) {
      print("GE data not detected, please double check if GE data files are properly named, or set doGE = FALSE to skip GE data processing")
      stop()
    } else {
      print("Start processing GE data")
    }

    # load and extract gene expression data
    ge_path = paste0("./", folder_name, "/", ge_file_name)
    ge.list = lapply(ge_path, read.table, header = TRUE, stringsAsFactors = FALSE)
    ge.list = lapply(ge.list, function(x) x[(names(x) %in% c("Name", "TPM"))])
    ge_header = c("ENSG", "TPM")
    ge.list = lapply(ge.list, setNames, ge_header)
    if (exists("gdc_ge.list_FPKM")) {
      names(ge.list) = assayID[1:(length(assayID) - length(gdc_ge.list_FPKM))]
    } else {
      names(ge.list) = assayID
    }

    # filter out unexpected ENST/transcripts in ge.list
    ge.list = lapply(ge.list, function(x) {
      temp_ENST = grepl("^ENST.+$", x$ENSG)
      x = subset(x, subset = !temp_ENST)
      return(x)
    })

    # remove ENSG version suffix in ge.list
    ge.list = lapply(ge.list, function(x) {
      x$ENSG = gsub("\\.[[:digit:]]+$", "", x$ENSG)
      return(x)
    })

    # map gene expression data to GRCh38, or do homolog lifting if it is non-human
    if (speciesID == "hg38") {
      ge.list = lapply(ge.list, merge, x = GRCh38G, by = "ENSG")
    } else if (speciesID == "hg19") {
      ge.list = lapply(ge.list, merge, x = GRCh37G, by = "ENSG")
    } else {
      # homolog lifting from Mouse to Human
      ge.list = lapply(ge.list, merge, x = GRCm2h38C, by.x = "ENSG_M", by.y = "ENSG")
      ge.list = lapply(ge.list, function(x) x[, -c(1, 2)])
    }
    ge.list = lapply(ge.list, function(x) x[, c(2, 6)]) # for xCell

    # append TCGA data if available
    if (exists("gdc_ge.list.c_xcell")) {
      ge.list = c(ge.list, gdc_ge.list.c_xcell)
    }

    # filter out sample with empty ge data, using backwards for loop
    if (exists("gdc_ge.list_FPKM")) {
      plot_name_rna = plot_name[1:(length(assayID) - length(gdc_ge.list_FPKM))]
      assayID_rna = assayID[1:(length(assayID) - length(gdc_ge.list_FPKM))]
    } else {
      plot_name_rna = plot_name
      assayID_rna = assayID
    }
    for (i in length(ge.list):1) {
      if (nrow(ge.list[[i]]) == 0) {
        ge.list[[i]] = NULL
        plot_name_rna = plot_name_rna[-i]
        assayID_rna = assayID_rna[-i]
      }
    }
    rm(i)

    # append grouped list to original list
    ge.list.c = ge.list

    # remove temp ge data
    rm(ge.list, ge_file_name, ge_header, ge_path)

    # unify gene numbers in ge.list.c in case samples have differnt number of genes
    ge.unif = dplyr::bind_rows(ge.list.c)
    ge.unif["Occurrence"] = 1
    ge.unif = ge.unif[, -2]
    ge.unif = ge.unif %>% dplyr::group_by(Gene) %>% dplyr::summarise(TotalOccurrence = sum(Occurrence))
    ge.unif = subset(ge.unif, subset = TotalOccurrence == length(ge.list.c))
    ge.unif = unlist(ge.unif[, 1])
    ge.list.c = lapply(ge.list.c, function(x) {
      x = subset(x, subset = Gene %in% ge.unif)
      return(x)
    })
    rm(ge.unif)

    # merge separate dataframes into one and rename TPM columns
    ge.xcell = ge.list.c[[1]]
    for (i in 2:length(ge.list.c)) {
      ge.xcell = cbind(ge.xcell, ge.list.c[[i]][, 2])
    }
    rm(i)
    colnames(ge.xcell) = c("Gene", plyr::mapvalues(names(ge.list.c), from = groupInfo$assayID, to = groupInfo$aliasID, warn_missing = FALSE))

    # calculate average GE for duplicated genes
    ge.xcell = ge.xcell %>% dplyr::group_by(Gene) %>% dplyr::summarise_all(.vars = colnames(ge.xcell)[-1], .fun = mean) # non-unique colnames error doesn't have an effect
    print("GE data processing completed")
  }

  # if condition for whether to conduct local analysis
  if (doLocalAnalysis == TRUE) {

    # check if GE data are already reformed
    if (is.null(ge.xcell)) {
      print("Reformed GE data not detected, please double check if GE data are already reformed, or set doLocalAnalysis = FALSE to skip local analysis")
      stop()
    } else {
      print("Start local analysis")
    }

    # reform ge.xcell to ge.xcell.prep to meet xCell input requirement
    tempRownames = unlist(ge.xcell[, "Gene"])
    tempRownamesUniq = unique(tempRownames)
    ge.xcell.prep = as.matrix(ge.xcell[, -1], stringAsFactor = FALSE)
    rownames(ge.xcell.prep) = tempRownamesUniq
    rm(tempRownames, tempRownamesUniq)

    # subset ge.xcell.prep to be consistent with downstream colSliceOrder
    if (length(colSliceOrder) != length(grpName)) {
      print(glue::glue("Group not processed in xCell: {setdiff(grpName, colSliceOrder)}"))
      colnames_temp = colnames(ge.xcell.prep)
      grp.list.xcell_temp = list()
      for (i in 1:length(grpName)) {
        grp.list.xcell_temp[[i]] = grp.list[[i]][grp.list[[i]] %in% names(ge.list.c)]
      }
      rm(i)
      names(grp.list.xcell_temp) = grpName
      grp.list.xcell_temp = grp.list.xcell_temp[names(grp.list.xcell_temp) %in% colSliceOrder]
      groupInfo_temp = subset(groupInfo, subset = Group %in% colSliceOrder)
      colnames_temp = colnames_temp %in% groupInfo_temp$aliasID
      ge.xcell.prep = subset(ge.xcell.prep, select = colnames_temp)
      rm(colnames_temp, grp.list.xcell_temp, groupInfo_temp)
    }

    # local xCell analysis
    ge.xcell.result = xCell::xCellAnalysis(ge.xcell.prep)

    # remove xCellAnalysis byproduct variables
    rm(ge.xcell.prep)
    rm(progressBar, iSample, nSamples, envir = .GlobalEnv)
  }

  # add variables to temp_prepareVdata_xCell_returnList
  temp_prepareVdata_xCell_returnList = list(
    "ge.list.c" = ge.list.c,
    "ge.xcell" = ge.xcell,
    "ge.xcell.result" = ge.xcell.result,
    "assayID_rna" = assayID_rna,
    "plot_name_rna" = plot_name_rna
  )

  # remove variables already added to temp_prepareVdata_xCell_returnList
  rm(list = names(temp_prepareVdata_xCell_returnList))

  # filter out empty variables, using backwards for loop
  for (i in length(temp_prepareVdata_xCell_returnList):1) {
    if (is.null(temp_prepareVdata_xCell_returnList[[i]])) {
      temp_prepareVdata_xCell_returnList[[i]] = NULL
    }
  }
  rm(i)

  # remove extracted global settings
  rm(list = names(globalSettings_returnList))

  # end of v_prepareVdata_xCell function
  print("v_prepareVdata_xCell run completed, return value saved to the global environment in **prepareVdata_xCell_returnList**")
  return(temp_prepareVdata_xCell_returnList)
}



#' Calculate log10 fold-change value for module xCell
#'
#' (Internal) Helper function, used to calculate log10 fold-change value for module xCell, should be called within the main function (v_chmXcell).
#'
#' @keywords internal

# v_chmFoldChangeLog10_xCell function
v_chmFoldChangeLog10_xCell = function(outputFolderPath, log10Threshold, grpName_fc, filterNoTPM) {

  # get variables from parent function
  studyID = get("studyID", envir = parent.frame())

  # temporarily turn ge.chm.pmg into xcell.pmg for downstream calculation
  xcell.pmg = get("ge.chm.pmg", envir = parent.frame())

  # group up and calculate average xCell enrichment score
  xcell.pmg.fc = subset(xcell.pmg, subset = Group %in% grpName_fc)
  xcell.pmg.fc = xcell.pmg.fc %>% dplyr::group_by(Cell.Type, Group) %>% dplyr::summarise_at(.vars = "Enrichment.Score", .fun = list(Enrichment.Score_avg = mean))

  # turn xcell.pmg.fc into a list
  xcell.foldchange = list()
  for (i in 1:length(grpName_fc)) {
    xcell.foldchange[[i]] = subset(xcell.pmg.fc, subset = Group == grpName_fc[i])[, c(1, 3)]
  }
  rm(i, xcell.pmg.fc)
  names(xcell.foldchange) = grpName_fc

  # replace NA and negative value with 0
  xcell.foldchange = lapply(xcell.foldchange, function(x) {
    x[is.na(x[, 2]), 2] = 0
    x[x[, 2] < 0, 2] = 0
    return(x)
  })

  # filter out genes with Enrichment.Score = 0 in both groups
  if (filterNoTPM == TRUE) {
    xcell.foldchange = lapply(xcell.foldchange, function(x) {
      noES = (xcell.foldchange[[1]][, 2] == 0) & (xcell.foldchange[[2]][, 2] == 0)
      x = x[!noES, ]
    })
  }

  # add 10e-32 to fix 0 denominator issue
  min0offset_fc_xcell = min(sapply(xcell.foldchange, function(x) {min(x[x[, 2] > 0, 2])})) / 10
  min0offset_fc_xcell = 10 ^ (floor(log10(min0offset_fc_xcell)))
  xcell.foldchange = lapply(xcell.foldchange, function(x) {
    x[, 2] = x[, 2] + min0offset_fc_xcell # add 10e-32 to fix log(0) issue
    return(x)
  })

  # calculate fold change
  xcell.foldchange[[3]] = xcell.foldchange[[grpName_fc[2]]]
  xcell.foldchange[[3]][, 2] = log10(xcell.foldchange[[3]][, 2] / xcell.foldchange[[grpName_fc[1]]][, 2])
  xcell.foldchange = xcell.foldchange[[3]]
  colnames(xcell.foldchange) = c("Cell_Type", "Log10_FC")

  # classify fold change based on threshold
  xcell.foldchange["Exp_Level"] = dplyr::case_when(
    xcell.foldchange[, 2] >= log10Threshold[1] ~ "Up-Regulated",
    xcell.foldchange[, 2] <= log10Threshold[2] ~ "Down-Regulated",
    (xcell.foldchange[, 2] < log10Threshold[1]) & (xcell.foldchange[, 2] > log10Threshold[2]) ~ "Within-Threshold"
  )

  # select up- and down-regulated genes
  xcell.foldchange.udr = subset(xcell.foldchange, subset = Exp_Level != "Within-Threshold")

  # write xcell.foldchange to csv file
  write.csv(xcell.foldchange, file = paste0(outputFolderPath, studyID, "_xCell_foldchange_3ExprLvls.csv"), quote = FALSE, row.names = FALSE)

  # end of chmFoldChangeLog10 function
  print(as.character(glue::glue("v_chmFoldChangeLog10_xCell completed, output csv file saved in {outputFolderPath}")))
  return(xcell.foldchange)
}



#' Combine the main body and side annotation of heatmap for module xCell
#'
#' (Internal) Helper function, used to combine the main body and side annotation of heatmap for module xCell, should be called within the main function (v_chmXcell).
#'
#' @import magick
#'
#' @keywords internal

# v_magick_xCell function
v_magick_xCell = function(outputFolderPath, sigType) {

  # get variables from parent function
  studyID = get("studyID", envir = parent.frame())
  chm_suffix = get("chm_suffix", envir = parent.frame())

  # load plots to be combined
  chm_mainbody = image_read(path = paste0(outputFolderPath, "HeatMap4K_", studyID, "_CellTypeEnrichmentScore", chm_suffix, "_", sigType, ".png"))
  chm_bpanno = image_read(path = paste0(outputFolderPath, "BoxPlotAnno4K_", studyID, "_annotation_xCell", chm_suffix, "_", sigType, ".png"))

  # combine bpanno and mainbody, watch for the order, from left to right
  chm_combined = image_append(image = c(chm_bpanno, chm_mainbody), stack = FALSE)

  # output combined plot
  image_write(chm_combined, path = paste0(outputFolderPath, "CombinedHeatMap4K_", studyID, "_CellTypeEnrichmentScore", chm_suffix, "_", sigType, ".png"))

  # remove temp variables
  rm(chm_mainbody, chm_bpanno, chm_combined)
}

# preset globalVariables for R CMD check
utils::globalVariables(c("GRCm2h38C", "Gene", "Occurrence", "TotalOccurrence", "gdc_ge.list.c_xcell", "gdc_ge.list_FPKM", "iSample", "nSamples", "progressBar", "Cell.Type", "Exp_Level"))
