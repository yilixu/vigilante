#' Prepare data for module: CHM_G (Gene)
#'
#' The workflow of vigilante is highly module-based. To ensure a successful and smooth run, vigilante needs to prepare input data before continuing.
#'
#' @param doGE logic, whether to prepare Gene Expression (GE) data, if FALSE, no GE data will be available for downstream v_chmSignaturePanel function; if TRUE, please make sure GE data files are properly named, see Details for more information about file naming.
#'
#' @details
#' Oftentimes input data files generated by upstream tools came with diverse naming conventions. It might be easy for the user to recognize those files, but not for vigilante if there is no recognizable patterns.
#'
#' To make input data files clear to vigilante, it would be nice to have them named something like "studyID_sampleID_(other descriptions).file extension". Here "studyID" is the name of the study or project, and it will be used in multiple naming situations (such as on the plot, or in the output file names), so it is recommended to be concise and meaningful.
#'
#' For module CHM_G, currently supported input data files are listed below, please contact the author if you want to add more files to the supported list:
#' Gene Expression (GE): *cDNA_genes.sf for Salmon
#'
#' @return list, because R CMD check discourages assignments to the global environment within functions, user needs to run the function with explicitly assigning the return value to a global variable named "prepareVdata_CHM_G_returnList", which will be a list containing the required variables for downstream analyses.
#'
#' @export
#'
# v_prepareVdata_CHM_G function
v_prepareVdata_CHM_G = function(doGE = FALSE) {

  # ask user to make sure v_prepareVdata_CHM_G function return value is assigned to the global variable named "prepareVdata_CHM_G_returnList"
  status_returnValue = menu(choices = c("Yes", "No"), title = "\nIs v_prepareVdata_CHM_G function return value assigned to the global variable named 'prepareVdata_CHM_G_returnList'?")
  if (status_returnValue == 1) {
    print("Function return value is properly assigned, now continue to the next step")
  } else if (status_returnValue == 2) {
    print("Please follow the instruction to assign the function return value before continue to the next step")
    stop()
  } else {
    print("Please choose a valid answer")
    stop()
  }
  rm(status_returnValue)

  # check if globalSettings_returnList exists
  if (!exists("globalSettings_returnList")) {
    print("globalSettings_returnList not detected, please follow the instruction and run v_globalSettings function before continue")
    stop()
  } else {
    print("globalSettings_returnList detected, start extracting global settings")
  }

  # extract global settings from return list
  for (i in 1:length(globalSettings_returnList)) {
    assign(x = names(globalSettings_returnList)[i], value = globalSettings_returnList[[i]])
  }
  rm(i)

  # preset variables for temp_prepareVdata_CHM_G_returnList
  ge.list = NULL
  assayID_rna = NULL
  plot_name_rna = NULL

  # if condition for whether to reform GE data
  if (doGE == TRUE) {

    # check if GE data exist
    ge_file_name = dir(path = folder_name, pattern = glob2rx("*cDNA_genes.sf"))
    if (length(ge_file_name) == 0) {
      print("GE data not detected, please double check if GE data files are properly named, or set doGE = FALSE to skip GE data processing")
      stop()
    } else {
      print("Start processing GE data")
    }

    # load and extract gene expression data
    ge_path = paste0("./", folder_name, "/", ge_file_name)
    ge.list = lapply(ge_path, read.table, header = TRUE, stringsAsFactors = FALSE)
    ge.list = lapply(ge.list, function(x) x[(names(x) %in% c("Name", "TPM"))])
    ge_header = c("ENSG", "TPM")
    ge.list = lapply(ge.list, setNames, ge_header)
    if (exists("gdc_ge.list_FPKM")) {
      names(ge.list) = assayID[1:(length(assayID) - length(gdc_ge.list_FPKM))]
    } else {
      names(ge.list) = assayID
    }

    # append TCGA data if available
    if (exists("gdc_ge.list.c_chm")) {
      ge.list = c(ge.list, gdc_ge.list.c_chm)
    }

    # filter out sample with empty ge data, using backwards for loop
    if (exists("gdc_ge.list_FPKM")) {
      plot_name_rna = plot_name[1:(length(assayID) - length(gdc_ge.list_FPKM))]
      assayID_rna = assayID[1:(length(assayID) - length(gdc_ge.list_FPKM))]
    } else {
      plot_name_rna = plot_name
      assayID_rna = assayID
    }
    for (i in length(ge.list):1) {
      if (nrow(ge.list[[i]]) == 0) {
        ge.list[[i]] = NULL
        plot_name_rna = plot_name_rna[-i]
        assayID_rna = assayID_rna[-i]
      }
    }
    rm(i)

    # select samples in groupInfo
    ge.list = ge.list[names(ge.list) %in% groupInfo$assayID]

    # filter out unexpected ENST/transcripts in ge.list
    ge.list = lapply(ge.list, function(x) {
      temp_ENST = grepl("^ENST.+$", x$ENSG)
      x = subset(x, subset = !temp_ENST)
      return(x)
    })

    # remove ENSG version suffix in ge.list
    ge.list = lapply(ge.list, function(x) {
      x$ENSG = gsub("\\.[[:digit:]]+$", "", x$ENSG)
      return(x)
    })

    # map gene expression data to GRCh38/GRCm38
    if (speciesID == "hg38") {
      ge.list = lapply(ge.list, merge, x = GRCh38G, by = "ENSG")
      ge.list = lapply(ge.list, function(x) x[, c(1, 6)]) # for ComplexHeatmap
    } else if (speciesID == "hg19") {
      ge.list = lapply(ge.list, merge, x = GRCh37G, by = "ENSG")
      ge.list = lapply(ge.list, function(x) x[, c(1, 6)]) # for ComplexHeatmap
    } else {
      ge.list = lapply(ge.list, merge, x = GRCm38G, by = "ENSG")
      ge.list = lapply(ge.list, function(x) x[, c(1, 6)]) # for ComplexHeatmap
    }

    # remove temp ge data
    rm(ge_file_name, ge_path, ge_header)
  }

  # add variables to temp_prepareVdata_CHM_G_returnList
  temp_prepareVdata_CHM_G_returnList = list(
    "ge.list" = ge.list,
    "assayID_rna" = assayID_rna,
    "plot_name_rna" = plot_name_rna
  )

  # remove variables already added to temp_prepareVdata_CHM_G_returnList
  rm(list = names(temp_prepareVdata_CHM_G_returnList))

  # filter out empty variables, using backwards for loop
  for (i in length(temp_prepareVdata_CHM_G_returnList):1) {
    if (is.null(temp_prepareVdata_CHM_G_returnList[[i]])) {
      temp_prepareVdata_CHM_G_returnList[[i]] = NULL
    }
  }
  rm(i)

  # remove extracted global settings
  rm(list = names(globalSettings_returnList))

  # end of v_prepareVdata_CHM_G function
  print("v_prepareVdata_CHM_G run completed, return value saved to the global environment in **prepareVdata_CHM_G_returnList**")
  return(temp_prepareVdata_CHM_G_returnList)
}



#' Calculate log10 fold-change value for module CHM_G/T (both Gene and Transcript)
#'
#' (Internal) Helper function, used to calculate log10 fold-change value for module CHM_G/T (both Gene and Transcript), should be called within the respective main function (v_chmSignaturePanel for Gene and v_chmTranscript for Transcript).
#'
#' @keywords internal

# v_chmFoldChangeLog10 function
v_chmFoldChangeLog10 = function(outputFolderPath, log10Threshold, grpName_fc, TPM2RHKG, filterNoTPM) {

  # get variables from parent function
  studyID = get("studyID", envir = parent.frame())
  grp.list = get("grp.list", envir = parent.frame())
  if (speciesID == "hg38") {
    GRCh38G = get("GRCh38G", envir = parent.frame())
  } else if (speciesID == "hg19") {
    GRCh37G = get("GRCh37G", envir = parent.frame())
  } else {
    GRCm38G = get("GRCm38G", envir = parent.frame()) # used for mouse
  }

  # set subgroup for fold change
  grp.list.fc = grp.list[names(grp.list) %in% grpName_fc]

  # temporarily turn te.list into ge.list for downstream calculation
  if (TPM2RHKG == "FPKM") {
    ge.list = get("te.list", envir = parent.frame())
    ge.list = lapply(ge.list, function(x) x = x[, c(1, 3)])
  } else {
    ge.list = get("ge.list", envir = parent.frame())
  }

  # group up and calculate average TPM
  ge.grp = list()
  for (i in 1:length(grpName_fc)) {
    ge.grp[[i]] = ge.list[names(ge.list) %in% grp.list.fc[[i]]]
  }
  rm(i)
  names(ge.grp) = names(grp.list.fc)
  ge.grp.avg = list()
  ge.grp.avg = lapply(ge.grp, dplyr::bind_rows)
  ge.grp.avg = lapply(ge.grp.avg, function(x) {
    if (TPM2RHKG != "FPKM") {
      x = dplyr::group_by(x, ENSG)
      if (TPM2RHKG == TRUE) {
        x = dplyr::summarise(x, TPM_avg = mean(RHKG))
      } else {
        x = dplyr::summarise(x, TPM_avg = mean(TPM))
      }
    } else if (TPM2RHKG == "FPKM") {
      x = dplyr::group_by(x, Transcript)
      x = dplyr::summarise(x, TPM_avg = mean(TPM))
    }
    x = as.data.frame(x)
  })

  # replace NA and negative value with 0
  ge.foldchange = lapply(ge.grp.avg, function(x) {
    x[is.na(x[, 2]), 2] = 0
    x[x[, 2] < 0, 2] = 0
    return(x)
  })

  # filter out genes with TPM = 0 in both groups
  if (filterNoTPM == TRUE) {
    ge.foldchange = lapply(ge.foldchange, function(x) {
      noTPM = (ge.foldchange[[1]][, 2] == 0) & (ge.foldchange[[2]][, 2] == 0)
      x = x[!noTPM, ]
    })
  }

  # add 10e-5 to fix log(0) issue
  min0offset_fc = min(sapply(ge.foldchange, function(x) {min(x[x[, 2] > 0, 2])})) / 10
  min0offset_fc = 10 ^ (floor(log10(min0offset_fc)))
  ge.foldchange = lapply(ge.foldchange, function(x) {
    if (TPM2RHKG == TRUE) {
      x[, 2] = x[, 2] + min0offset_fc # add 10e-3 to fix log(0) issue
    } else {
      x[, 2] = x[, 2] + min0offset_fc # add 10e-5 to fix log(0) issue
    }
    return(x)
  })

  # calculate fold change
  ge.foldchange[[3]] = ge.foldchange[[grpName_fc[2]]]
  ge.foldchange[[3]][, 2] = log10(ge.foldchange[[3]][, 2] / ge.foldchange[[grpName_fc[1]]][, 2])
  ge.foldchange = ge.foldchange[[3]]
  colnames(ge.foldchange) = c(ifelse(TPM2RHKG == "FPKM", "Transcript", "ENSG"), "Log10_FC")

  # classify fold change based on threshold
  ge.foldchange["Exp_Level"] = dplyr::case_when(
    ge.foldchange[, 2] >= log10Threshold[1] ~ "Up-Regulated",
    ge.foldchange[, 2] <= log10Threshold[2] ~ "Down-Regulated",
    (ge.foldchange[, 2] < log10Threshold[1]) & (ge.foldchange[, 2] > log10Threshold[2]) ~ "Within-Threshold"
  )

  # below only used for GE
  if (TPM2RHKG != "FPKM") {
    # map fold change data to ENSG reference
    if (speciesID == "hg38") {
      ge.foldchange = dplyr::inner_join(ge.foldchange, GRCh38G, by = "ENSG")
      ge.foldchange = ge.foldchange[, c(1, 4, 3, 2)]
    } else if (speciesID == "hg19") {
      ge.foldchange = dplyr::inner_join(ge.foldchange, GRCh37G, by = "ENSG")
      ge.foldchange = ge.foldchange[, c(1, 4, 3, 2)]
    } else {
      ge.foldchange = dplyr::inner_join(ge.foldchange, GRCm38G, by = "ENSG")
      ge.foldchange = ge.foldchange[, c(1, 4, 3, 2)] # used for mouse
    }

    # write ge.foldchange to csv file (for potential IPA input)
    tempCSV = ge.foldchange
    colnames(tempCSV) = c("ENSEMBL_ID", "Gene", "Expression_Level", "Log10_FC")
    write.csv(tempCSV, file = paste0(outputFolderPath, studyID, "_CHM_G_foldchange_3ExprLvls.csv"), quote = FALSE, row.names = FALSE)
    rm(tempCSV)
  }

  # end of v_chmFoldChangeLog10 function
  if (TPM2RHKG == "FPKM") {
    k_fc = get("k", envir = parent.frame())
    te.list.c = get("te.list.c", envir = parent.frame())
    names_fc = names(te.list.c[k_fc])
    print(as.character(glue::glue("v_chmFoldChangeLog10 for TE completed, of {names_fc}")))
    rm(k_fc, names_fc)
  } else {
    print(as.character(glue::glue("v_chmFoldChangeLog10 for GE completed, output csv file saved in {outputFolderPath}")))
  }
  return(ge.foldchange)
}

# preset globalVariables for R CMD check
utils::globalVariables(c("gdc_ge.list.c_chm", "RHKG", "Transcript"))
